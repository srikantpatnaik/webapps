<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Resizer</title>
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3f37c9;
            --success: #4cc9f0;
            --background: #121212;
            --card-bg: #1e1e1e;
            --text: #e0e0e0;
            --text-secondary: #a0a0a0;
            --border: #333;
            --input-bg: #2d2d2d;
            --input-border: #444;
            --button-bg: #4361ee;
            --button-hover: #3a56d4;
            --data-card-bg: #252525;
            --border-radius: 12px;
            --box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: var(--background);
            color: var(--text);
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 1.4rem;
            margin-bottom: 5px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 0.8rem;
            margin-bottom: 20px;
        }

        .card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 20px;
            margin-bottom: 15px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        input {
            flex: 1;
            padding: 12px;
            background: var(--input-bg);
            border: 2px solid var(--input-border);
            border-radius: var(--border-radius);
            color: var(--text);
            font-size: 1rem;
            transition: var(--transition);
        }

        input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.3);
        }

        /* Improved button styles */
        button {
            background: var(--button-bg);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 12px 20px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            min-height: 46px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        button:hover {
            background: var(--button-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(67, 97, 238, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        #submitBtn {
            background: var(--data-card-bg);
            color: var(--text);
            border: 1px solid var(--border);
        }

        #submitBtn:hover {
            background: var(--card-bg);
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(67, 97, 238, 0.3);
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
        }

        .error {
            background: #442c2c;
            color: #e76b6b;
            padding: 15px;
            border-radius: var(--border-radius);
            margin: 15px 0;
            text-align: center;
            border: 1px solid #6b3e3e;
        }

        .instructions {
            background: var(--data-card-bg);
            padding: 15px;
            border-radius: var(--border-radius);
            margin: 15px 0;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        /* Image upload and display */
        .image-upload-area {
            border: 2px dashed var(--border);
            border-radius: var(--border-radius);
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: var(--transition);
        }

        .image-upload-area:hover {
            border-color: var(--primary);
            background: rgba(67, 97, 238, 0.05);
        }

        .image-upload-area p {
            margin: 10px 0;
            color: var(--text-secondary);
        }

        .original-image-container, .resized-image-container {
            margin: 20px 0;
            text-align: center;
        }

        .original-image-container h3, .resized-image-container h3 {
            margin-bottom: 10px;
            color: var(--primary);
        }

        .image-container {
            display: inline-block;
            max-width: 100%;
            overflow: auto;
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            padding: 10px;
            background: var(--data-card-bg);
        }

        .image-container img {
            max-width: 100%;
            max-height: 500px;
            display: block;
            margin: 0 auto;
        }

        .resolution-info {
            margin-top: 8px;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Resize factors */
        .resize-factors {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .resize-btn {
            flex: 0 0 auto;
            background: var(--data-card-bg);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            padding: 10px 15px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .resize-btn:hover {
            background: var(--card-bg);
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(67, 97, 238, 0.3);
        }

        .resize-btn.active {
            background: var(--button-bg);
            color: white;
            border-color: var(--primary);
        }

        /* Action buttons */
        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .download-btn, .copy-btn {
            flex: 1;
            min-width: 120px;
        }

        .action-buttons button {
            flex: 1;
            min-width: 120px;
        }

        /* Slider styling */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: var(--input-bg);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        /* Responsive adjustments for larger screens */
        @media (min-width: 600px) {
            body {
                padding: 20px;
            }

            h1 {
                font-size: 2rem;
            }

            .subtitle {
                font-size: 1rem;
                margin-bottom: 25px;
            }

            .input-group {
                flex-direction: row;
            }

            input {
                min-width: 200px;
            }

            .card {
                padding: 25px;
                margin-bottom: 20px;
            }
        }

        @media (min-width: 768px) {
            .input-group {
                margin-bottom: 20px;
            }

            h1 {
                font-size: 2.2rem;
            }

            .image-container {
                max-width: 100%;
            }
        }

        @media (min-width: 1024px) {
            .image-layout {
                display: flex;
                gap: 20px;
            }

            .original-image-container, .resized-image-container {
                flex: 1;
                flex-basis: 0;
            }

            .image-container {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Image Resizer</h1>
            <div class="subtitle">Paste an image and resize it to your preferred dimensions</div>
        </header>

        <div class="instructions">
            <p><strong>How to use:</strong></p>
            <ol>
                <li>Paste an image using Ctrl+V (or Cmd+V on Mac) anywhere on the page</li>
                <li>Alternatively, drag and drop an image file or click the upload area</li>
                <li>Or paste an image URL in the text box and click "Load Image"</li>
                <li>By default, resized image will be 0.6x of original size</li>
                <li>Optionally select another resize factor from the buttons (0.3x, 0.6x, 0.8x, 1.3x, 1.5x)</li>
            </ol>
        </div>

        <main>
            <div class="card">
                <div class="image-upload-area" id="uploadArea">
                    <div>ðŸ“‹</div>
                    <h3>Paste or Drop Image</h3>
                    <p>Press Ctrl+V to paste an image from clipboard, or drag & drop an image file here</p>
                    <p id="imageInfo" class="resolution-info">No image loaded</p>
                </div>

                <div class="input-group">
                    <label for="imageUrl">Or paste image URL:</label>
                    <input type="text" id="imageUrl" placeholder="Paste image URL here...">
                    <button id="submitBtn">Load Image</button>
                </div>
                
                <div id="imageLayout" class="image-layout">
                    <div class="original-image-container" id="originalContainer" style="display: none;">
                        <h3>Original Image</h3>
                        <div class="image-container" style="position: relative;">
                            <img id="originalImage" src="" alt="Original image">
                            <div class="resolution-info" id="originalResolution">Resolution: --</div>

                            <!-- Canvas overlay for cropping -->
                            <canvas id="cropCanvas" style="position: absolute; top: 0; left: 0; pointer-events: none; display: none; cursor: crosshair;"></canvas>
                        </div>
                    </div>

                    <div class="resized-image-container" id="resizedContainer" style="display: none;">
                        <h3>Resized Image</h3>
                        <div class="image-container">
                            <img id="resizedImage" src="" alt="Resized image">
                            <div class="resolution-info" id="resizedResolution">Resolution: --</div>
                        </div>
                    </div>
                </div>
                
                <!-- Removed default scale buttons - only using continuous slider -->

                <!-- Slider for continuous resolution scaling -->
                <div id="resolutionSliderSection" style="display: none; margin-top: 20px;">
                    <label for="resolutionSlider" style="display: block; margin-bottom: 10px; text-align: center;">Scale Image (Continuous):</label>
                    <input type="range" id="resolutionSlider" min="0.1" max="2.0" step="0.01" value="0.6" style="width: 100%; margin-bottom: 10px;">
                    <div style="display: flex; justify-content: space-between; font-size: 0.8rem; color: var(--text-secondary);">
                        <span id="minResolutionLabel">10%</span>
                        <span id="currentScaleValue">60%</span>
                        <span id="maxResolutionLabel">200%</span>
                    </div>
                </div>
                
                <!-- Crop functionality - now automatic -->
                <div id="cropControls" class="input-group" style="display: none; margin-top: 20px;">
                    <button id="resetCropBtn" class="resize-btn">Reset Crop</button>
                    <button id="applyCropBtn" class="resize-btn">Apply Crop</button>
                </div>

                <div id="actionButtons" class="action-buttons" style="display: none;">
                    <!-- Removed download and copy buttons as requested -->
                </div>
            </div>
            
            <div id="errorContainer"></div>
        </main>
    </div>

    <script>
        // DOM elements
        const uploadArea = document.getElementById('uploadArea');
        const imageUrl = document.getElementById('imageUrl');
        const submitBtn = document.getElementById('submitBtn');
        const imageInfo = document.getElementById('imageInfo');
        const originalContainer = document.getElementById('originalContainer');
        const originalImage = document.getElementById('originalImage');
        const originalResolution = document.getElementById('originalResolution');
        const resizedContainer = document.getElementById('resizedContainer');
        const resizedImage = document.getElementById('resizedImage');
        const resizedResolution = document.getElementById('resizedResolution');
        const resizeFactors = document.getElementById('resizeFactors');
        const actionButtons = document.getElementById('actionButtons');
        const errorContainer = document.getElementById('errorContainer');

        let originalImageData = null;
        let currentResizeFactor = 0.6; // Changed default to 0.6x

        // Resolution range for the slider (min and max factors)
        const minFactor = 0.1;  // 10% of original size
        const maxFactor = 2.0;  // 200% of original size
        const defaultFactor = 0.6;  // Default at 60%

        // Set up paste listener on the entire page
        document.addEventListener('paste', handlePaste);
        
        // Set up drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.style.borderColor = 'var(--primary)';
            uploadArea.style.backgroundColor = 'rgba(67, 97, 238, 0.1)';
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.style.borderColor = 'var(--border)';
            uploadArea.style.backgroundColor = 'transparent';
        });
        
        uploadArea.addEventListener('drop', handleDrop);
        
        // Click to upload functionality
        uploadArea.addEventListener('click', () => {
            // Create a file input element to allow file selection
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*';
            fileInput.onchange = handleFileSelect;
            fileInput.click();
        });

        // Event listener for the URL submission
        submitBtn.addEventListener('click', () => {
            const url = imageUrl.value.trim();
            if (url) {
                loadImageFromUrl(url);
            } else {
                showError('Please enter an image URL');
            }
        });

        // Allow pressing Enter in the URL input
        imageUrl.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitBtn.click();
            }
        });
        
        // Skip resize buttons since we're only using the continuous slider

        // Add event listener for the continuous resolution slider
        const resolutionSlider = document.getElementById('resolutionSlider');
        const currentScaleValue = document.getElementById('currentScaleValue');

        resolutionSlider.addEventListener('input', function() {
            const factor = parseFloat(this.value);

            // Update the displayed scale percentage
            currentScaleValue.textContent = Math.round(factor * 100) + '%';

            // Update the current resize factor and resize the image
            currentResizeFactor = factor;

            // Remove active class from all manual resize buttons
            resizeBtns.forEach(b => b.classList.remove('active'));

            // Resize the image with the calculated factor
            resizeImage(factor);
        });
        
        
        function handlePaste(e) {
            if (!e.clipboardData || !e.clipboardData.items) {
                showError('Clipboard data not available');
                return;
            }

            const items = e.clipboardData.items;

            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    const blob = items[i].getAsFile();
                    if (blob) {
                        loadImageToFile(blob);
                        break;
                    }
                }
            }
        }
        
        function handleDrop(e) {
            e.preventDefault();
            uploadArea.style.borderColor = 'var(--border)';
            uploadArea.style.backgroundColor = 'transparent';
            
            const files = e.dataTransfer.files;
            
            for (let i = 0; i < files.length; i++) {
                if (files[i].type.startsWith('image/')) {
                    loadImageToFile(files[i]);
                    break;
                }
            }
        }
        
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImageToFile(file);
            }
        }

        function loadImageFromUrl(url) {
            // Validate URL format
            try {
                new URL(url);
            } catch (e) {
                showError('Invalid URL format');
                return;
            }

            // Check if URL is for an image
            if (!/\.(jpeg|jpg|gif|png|webp|bmp|svg)$/i.test(url)) {
                showError('URL does not appear to be an image');
                return;
            }

            // Create an image object to load the image
            const img = new Image();

            img.crossOrigin = 'Anonymous'; // Handle CORS if possible
            img.onload = function() {
                // Convert image to data URL
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;

                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                originalImageData = canvas.toDataURL('image/jpeg', 0.9);
                originalImageDataBeforeCrop = canvas.toDataURL('image/jpeg', 0.9); // Store original image data

                // Display original image
                originalImage.src = originalImageData;
                originalContainer.style.display = 'block';

                const width = img.width;
                const height = img.height;
                originalResolution.textContent = `Resolution: ${width} Ã— ${height}px`;
                imageInfo.textContent = `Image loaded: ${width} Ã— ${height}px`;

                // Store original dimensions
                originalImageDimensions = { width, height };

                // Set default resize factor to 0.6 and update the slider
                currentResizeFactor = 0.6;
                resolutionSlider.value = 0.6;
                currentScaleValue.textContent = '60%';

                // Show the resolution slider section
                document.getElementById('resolutionSliderSection').style.display = 'block';
                // Show crop controls
                cropControls.style.display = 'flex';
                actionButtons.style.display = 'none'; // Hide action buttons as requested

                // Setup and show the crop canvas automatically
                setupCropCanvas();
                cropCanvas.style.display = 'block';
                cropCanvas.style.pointerEvents = 'auto';

                // Add event listeners for drawing the rectangle
                addCropEventListeners();

                // Initially show resized image at 0.6x
            };

            img.onerror = function() {
                showError('Failed to load image from URL. The image may not be accessible due to CORS policies.');
            };

            img.src = url;
        }
        
        function loadImageToFile(file) {
            const reader = new FileReader();

            reader.onload = function(e) {
                originalImageData = e.target.result;
                originalImageDataBeforeCrop = e.target.result; // Store original image data

                // Display original image
                originalImage.src = originalImageData;
                originalContainer.style.display = 'block';

                // Wait for image to load to get dimensions
                originalImage.onload = function() {
                    const width = originalImage.naturalWidth;
                    const height = originalImage.naturalHeight;
                    originalResolution.textContent = `Resolution: ${width} Ã— ${height}px`;
                    imageInfo.textContent = `Image loaded: ${width} Ã— ${height}px`;

                    // Store original dimensions
                    originalImageDimensions = { width, height };

                    // Set default resize factor to 0.6 and update the slider
                    currentResizeFactor = 0.6;
                    resolutionSlider.value = 0.6;
                    currentScaleValue.textContent = '60%';

                    // Show the resolution slider section
                    document.getElementById('resolutionSliderSection').style.display = 'block';
                    // Show crop controls
                    cropControls.style.display = 'flex';
                    actionButtons.style.display = 'none'; // Hide action buttons as requested

                    // Setup and show the crop canvas automatically
                    setupCropCanvas();
                    cropCanvas.style.display = 'block';
                    cropCanvas.style.pointerEvents = 'auto';

                    // Add event listeners for drawing the rectangle
                    addCropEventListeners();

                    // Initially show resized image at 0.6x
                    resizeImage(0.6);
                };
            };

            reader.onerror = function() {
                showError('Error reading the image file');
            };

            reader.readAsDataURL(file);
        }
        
        function setCurrentFactor(factor) {
            // Update the scale value display but don't change the slider position
            // to maintain smooth continuous scaling
            currentScaleValue.textContent = Math.round(factor * 100) + '%';

            currentResizeFactor = factor;
        }

        function resizeImage(factor) {
            if (!originalImageData) return;

            const img = new Image();
            img.onload = function() {
                // Calculate new dimensions while preserving aspect ratio
                const newWidth = Math.floor(img.width * factor);
                const newHeight = Math.floor(img.height * factor);

                // Create canvas to draw the resized image
                const canvas = document.createElement('canvas');
                canvas.width = newWidth;
                canvas.height = newHeight;

                const ctx = canvas.getContext('2d');

                // Draw the image on the canvas with new dimensions
                ctx.drawImage(img, 0, 0, newWidth, newHeight);

                // Get the data URL of the resized image
                const resizedImageData = canvas.toDataURL('image/jpeg', 0.9);

                // Display the resized image
                resizedImage.src = resizedImageData;
                resizedContainer.style.display = 'block';

                // Update resolution info
                resizedResolution.textContent = `Resolution: ${newWidth} Ã— ${newHeight}px`;

                // Update current factor
                currentResizeFactor = factor;

                // Update the scale value display but don't change the slider position
                // to maintain smooth continuous scaling
                currentScaleValue.textContent = Math.round(factor * 100) + '%';

                // Automatically copy the resized image to clipboard
                copyResizedImageToClipboard(resizedImageData);
            };

            img.src = originalImageData;
        }
        
        
        function showError(message) {
            errorContainer.innerHTML = `<div class="error">${message}</div>`;
            
            // Clear error after 5 seconds
            setTimeout(() => {
                errorContainer.innerHTML = '';
            }, 5000);
        }
        
        function showSuccess(message) {
            errorContainer.innerHTML = `<div class="error" style="background: #2c442c; color: #6be770; border-color: #3e6b3e;">${message}</div>`;

            // Clear success message after 3 seconds
            setTimeout(() => {
                errorContainer.innerHTML = '';
            }, 3000);
        }

        function copyResizedImageToClipboard(imageData) {
            // Convert data URL to blob
            fetch(imageData)
                .then(res => res.blob())
                .then(blob => {
                    // Create a ClipboardItem with the blob
                    const clipboardItem = new ClipboardItem({ [blob.type]: blob });

                    // Write to clipboard
                    navigator.clipboard.write([clipboardItem])
                        .then(() => {
                            // Optionally show a success message
                            // showSuccess('Image automatically copied to clipboard!');
                        })
                        .catch(err => {
                            // Silently fail since automatic copying shouldn't interrupt the user
                            // showError('Failed to copy image: ' + err);
                        });
                })
                .catch(err => {
                    // Silently fail since automatic copying shouldn't interrupt the user
                    // showError('Error processing image for copy: ' + err);
                });
        }
        
        // Crop functionality variables - now automatic
        let isCropping = true; // Always in crop mode when image is loaded
        let isDrawing = false;
        let startX, startY, endX, endY;
        let originalImageDataBeforeCrop = null; // Store original image data before any cropping
        let originalImageDimensions = { width: 0, height: 0 }; // Store original dimensions
        let cropCanvas = document.getElementById('cropCanvas');
        let cropCtx = cropCanvas.getContext('2d');
        let resetCropBtn = document.getElementById('resetCropBtn');
        let applyCropBtn = document.getElementById('applyCropBtn');
        let cropControls = document.getElementById('cropControls');

        // Initialize crop functionality - now automatic
        function initCropFunctionality() {
            // Reset crop button
            resetCropBtn.addEventListener('click', () => {
                // Clear the crop rectangle
                startX = startY = endX = endY = null;
                redrawCropOverlay();

                // If we're in crop mode, keep the canvas visible
                if (isCropping) {
                    setupCropCanvas(); // Refresh the canvas in case image changed
                }
            });

            // Apply crop button
            applyCropBtn.addEventListener('click', () => {
                if (startX !== undefined && startY !== undefined &&
                    endX !== undefined && endY !== undefined) {
                    performCrop();
                } else {
                    showError('Please select a rectangle to crop');
                }
            });
        }

        // Setup the crop canvas dimensions to match the image
        function setupCropCanvas() {
            const img = originalImage;
            if (!img.complete) {
                img.onload = () => setupCropCanvas();
                return;
            }

            // Position the canvas to match the image
            const rect = img.getBoundingClientRect();
            const imageContainer = img.parentElement;

            // Set canvas dimensions to match the image display size
            cropCanvas.width = img.clientWidth;
            cropCanvas.height = img.clientHeight;

            // Position canvas absolutely over the image
            cropCanvas.style.width = img.clientWidth + 'px';
            cropCanvas.style.height = img.clientHeight + 'px';

            // Reset crop points
            cropPoints = [];
            redrawCropOverlay();
        }

        // Add event listeners for crop functionality - always active
        function addCropEventListeners() {
            cropCanvas.addEventListener('mousedown', handleCropMouseDown);
            cropCanvas.addEventListener('mousemove', handleCropMouseMove);
            cropCanvas.addEventListener('mouseup', handleCropMouseUp);

            // Also add a click listener on the document to reset when clicking outside
            document.addEventListener('click', handleDocumentClick);
        }

        // Handle mouse down for starting rectangle drawing
        function handleCropMouseDown(e) {
            // Always allow drawing when crop canvas is visible
            const rect = cropCanvas.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;

            isDrawing = true;
        }

        // Handle mouse move for drawing rectangle
        function handleCropMouseMove(e) {
            if (!isDrawing) return;

            const rect = cropCanvas.getBoundingClientRect();
            endX = e.clientX - rect.left;
            endY = e.clientY - rect.top;

            redrawCropOverlay();
        }

        // Handle mouse up for finishing rectangle
        function handleCropMouseUp(e) {
            if (!isDrawing) return;

            const rect = cropCanvas.getBoundingClientRect();
            endX = e.clientX - rect.left;
            endY = e.clientY - rect.top;

            isDrawing = false;

            redrawCropOverlay();
        }

        // Handle clicks outside the image area to reset crop
        function handleDocumentClick(e) {
            // Check if the click is outside both the original and resized image containers
            const originalContainer = document.getElementById('originalContainer');
            const resizedContainer = document.getElementById('resizedContainer');

            const isClickOnOriginal = originalContainer.contains(e.target);
            const isClickOnResized = resizedContainer.contains(e.target);

            if (!isClickOnOriginal && !isClickOnResized) {
                // Reset crop selection but keep crop mode active
                startX = startY = endX = endY = null;
                redrawCropOverlay();

                // Restore the original image and apply the current scale factor
                if (originalImageDataBeforeCrop) {
                    // Reset to the original image before any crops
                    originalImage.src = originalImageDataBeforeCrop;
                    originalImageData = originalImageDataBeforeCrop; // Reset the stored image data
                    // Update resolution info for the original image display
                    const img = new Image();
                    img.onload = function() {
                        const width = img.naturalWidth;
                        const height = img.naturalHeight;
                        originalResolution.textContent = `Resolution: ${width} Ã— ${height}px`;
                        imageInfo.textContent = `Image loaded: ${width} Ã— ${height}px`;
                        originalImageDimensions = { width, height }; // Update stored dimensions
                        // Apply the current scale factor
                        resizeImage(currentResizeFactor);
                    };
                    img.src = originalImageDataBeforeCrop;
                } else if (originalImageData) {
                    // If we don't have the original before crop, at least reset the current image
                    const img = new Image();
                    img.onload = function() {
                        const width = img.naturalWidth;
                        const height = img.naturalHeight;
                        originalResolution.textContent = `Resolution: ${width} Ã— ${height}px`;
                        imageInfo.textContent = `Image loaded: ${width} Ã— ${height}px`;
                        originalImageDimensions = { width, height }; // Update stored dimensions
                        // Apply the current scale factor
                        resizeImage(currentResizeFactor);
                    };
                    img.src = originalImageData;
                }
            }
        }

        // Redraw the crop overlay
        function redrawCropOverlay() {
            // Clear the canvas
            cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);

            // Draw the rectangle if we have start and end points
            if (startX !== undefined && startY !== undefined &&
                endX !== undefined && endY !== undefined) {

                const rectX = Math.min(startX, endX);
                const rectY = Math.min(startY, endY);
                const rectWidth = Math.abs(endX - startX);
                const rectHeight = Math.abs(endY - startY);

                // Draw the rectangle
                cropCtx.beginPath();
                cropCtx.rect(rectX, rectY, rectWidth, rectHeight);
                cropCtx.lineWidth = 2;
                cropCtx.strokeStyle = '#474787';
                cropCtx.stroke();

                // Draw corner markers
                const markerSize = 6;

                // Top-left corner
                cropCtx.fillStyle = '#ff4757';
                cropCtx.fillRect(rectX - markerSize/2, rectY - markerSize/2, markerSize, markerSize);

                // Top-right corner
                cropCtx.fillRect(rectX + rectWidth - markerSize/2, rectY - markerSize/2, markerSize, markerSize);

                // Bottom-left corner
                cropCtx.fillRect(rectX - markerSize/2, rectY + rectHeight - markerSize/2, markerSize, markerSize);

                // Bottom-right corner
                cropCtx.fillRect(rectX + rectWidth - markerSize/2, rectY + rectHeight - markerSize/2, markerSize, markerSize);
            }

            // If currently drawing, show the current rectangle
            if (isDrawing) {
                const rectX = Math.min(startX, endX);
                const rectY = Math.min(startY, endY);
                const rectWidth = Math.abs(endX - startX);
                const rectHeight = Math.abs(endY - startY);

                // Draw the current rectangle with a different style
                cropCtx.beginPath();
                cropCtx.rect(rectX, rectY, rectWidth, rectHeight);
                cropCtx.lineWidth = 2;
                cropCtx.strokeStyle = '#4CAF50'; // Green while drawing
                cropCtx.setLineDash([5, 3]); // Dashed line while drawing
                cropCtx.stroke();
                cropCtx.setLineDash([]); // Reset line dash
            }
        }

        // Perform the actual crop operation with rectangle
        async function performCrop() {
            if (typeof startX === 'undefined' || typeof startY === 'undefined' ||
                typeof endX === 'undefined' || typeof endY === 'undefined') {
                showError('Please select a rectangle to crop');
                return;
            }

            // Calculate the crop rectangle coordinates
            const cropX = Math.min(startX, endX);
            const cropY = Math.min(startY, endY);
            const cropWidth = Math.abs(endX - startX);
            const cropHeight = Math.abs(endY - startY);

            // Validate crop selection
            if (cropWidth <= 0 || cropHeight <= 0) {
                showError('Please select a valid crop area (more than a point)');
                return;
            }

            // Create a temporary image to work with
            const img = new Image();
            img.crossOrigin = "Anonymous"; // Handle potential CORS issues

            try {
                // Load the original image data
                img.src = originalImageData;

                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = () => {
                        reject(new Error('Failed to load image for cropping'));
                    };
                });

                // Get the display dimensions of the original image element
                const displayWidth = originalImage.clientWidth || originalImage.offsetWidth;
                const displayHeight = originalImage.clientHeight || originalImage.offsetHeight;

                // Calculate scale ratios between display and natural sizes
                const scaleX = img.naturalWidth / displayWidth;
                const scaleY = img.naturalHeight / displayHeight;

                // Calculate the actual crop coordinates in natural image space
                const actualCropX = Math.max(0, Math.round(cropX * scaleX));
                const actualCropY = Math.max(0, Math.round(cropY * scaleY));
                const actualCropWidth = Math.max(1, Math.round(cropWidth * scaleX));
                const actualCropHeight = Math.max(1, Math.round(cropHeight * scaleY));

                // Ensure crop doesn't exceed image bounds
                const boundedCropX = Math.min(actualCropX, img.naturalWidth - 1);
                const boundedCropY = Math.min(actualCropY, img.naturalHeight - 1);
                const boundedCropWidth = Math.min(actualCropWidth, img.naturalWidth - boundedCropX);
                const boundedCropHeight = Math.min(actualCropHeight, img.naturalHeight - boundedCropY);

                // Create a canvas for the cropped image
                const cropCanvas = document.createElement('canvas');
                cropCanvas.width = boundedCropWidth;
                cropCanvas.height = boundedCropHeight;
                const cropCtx = cropCanvas.getContext('2d');

                // Draw the cropped portion of the image
                cropCtx.drawImage(
                    img,
                    boundedCropX, boundedCropY, boundedCropWidth, boundedCropHeight,
                    0, 0, boundedCropWidth, boundedCropHeight
                );

                // Get the data URL of the cropped image
                const croppedImageData = cropCanvas.toDataURL('image/jpeg', 0.9);

                // Store the original image data before crop for reset functionality
                if (!originalImageDataBeforeCrop) {
                    originalImageDataBeforeCrop = originalImageData;
                }

                // Update the original image data to the cropped image so it can be further processed
                originalImageData = croppedImageData;

                // Update the original image display to show the cropped version
                originalImage.src = croppedImageData;

                // Update resolution info for the original image display
                const width = boundedCropWidth;
                const height = boundedCropHeight;
                originalResolution.textContent = `Resolution: ${width} Ã— ${height}px`;
                imageInfo.textContent = `Cropped image: ${width} Ã— ${height}px`;

                // Update original image dimensions
                originalImageDimensions = { width, height };

                // Keep crop canvas visible for continued cropping
                document.getElementById('cropCanvas').style.display = 'block';
                document.getElementById('cropCanvas').style.pointerEvents = 'auto';

                // Show the slider again for the cropped image
                document.getElementById('resolutionSliderSection').style.display = 'block';

                // Make sure the resized container is visible
                resizedContainer.style.display = 'block';

                // Apply the current resize factor to the cropped image
                // Wait a bit for the image to load before resizing
                setTimeout(() => {
                    resizeImage(currentResizeFactor);
                }, 50);

            } catch (error) {
                console.error('Crop error:', error);
                showError(`Crop failed: ${error.message}`);
            }
        }

        // No longer needed since we're doing simple rectangle cropping

        // Initialize the app
        window.addEventListener('load', () => {
            console.log('Image Resizer loaded. Ready to paste images!');

            // Set the 0.6x button as active by default
            const defaultBtn = document.querySelector('[data-factor="0.6"]');
            if (defaultBtn) {
                defaultBtn.classList.add('active');
            }

            // Set the default slider value
            if (resolutionSlider) {
                resolutionSlider.value = defaultFactor;
                currentScaleValue.textContent = Math.round(defaultFactor * 100) + '%';
            }

            // Initialize crop functionality
            initCropFunctionality();
        });
    </script>
</body>
</html>