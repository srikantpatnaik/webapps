<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Dashboard</title>
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3f37c9;
            --success: #4cc9f0;
            --background: #121212;
            --card-bg: #1e1e1e;
            --text: #e0e0e0;
            --text-secondary: #a0a0a0;
            --border: #333;
            --input-bg: #2d2d2d;
            --input-border: #444;
            --button-bg: #4361ee;
            --button-hover: #3a56d4;
            --data-card-bg: #252525;
            --border-radius: 12px;
            --box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: var(--background);
            color: var(--text);
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 1.4rem;
            margin-bottom: 5px;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 0.8rem;
            margin-bottom: 20px;
        }

        .card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 20px;
            margin-bottom: 15px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        input {
            flex: 1;
            padding: 12px;
            background: var(--input-bg);
            border: 2px solid var(--input-border);
            border-radius: var(--border-radius);
            color: var(--text);
            font-size: 1rem;
            transition: var(--transition);
        }

        input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.3);
        }

        /* Improved button styles */
        button {
            background: var(--button-bg);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 12px 20px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            min-height: 46px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        button:hover {
            background: var(--button-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(67, 97, 238, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        #submitBtn {
            background: var(--data-card-bg);
            color: var(--text);
            border: 1px solid var(--border);
        }

        #submitBtn:hover {
            background: var(--card-bg);
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(67, 97, 238, 0.3);
        }

        /* Weather data display */
        .weather-data {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .data-card {
            background: var(--data-card-bg);
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            padding: 15px;
            text-align: center;
        }

        .data-card h3 {
            color: var(--text-secondary);
            font-size: 0.8rem;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .data-card .value {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--text);
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
        }

        .error {
            background: #442c2c;
            color: #e76b6b;
            padding: 15px;
            border-radius: var(--border-radius);
            margin: 15px 0;
            text-align: center;
            border: 1px solid #6b3e3e;
        }

        .last-updated {
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.8rem;
            margin-top: 15px;
        }

        .city-display {
            text-align: center;
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--primary);
        }

        /* Weather Cards - Enhanced design - more compact and beautiful */
        .weather-cards-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .weather-card {
            background: var(--data-card-bg);
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            padding: 12px;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
            color: var(--text);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
            min-height: 80px;
        }

        .weather-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .city-name {
            font-size: 1rem;
            font-weight: 600;
            margin: 0;
            color: var(--primary);
            flex-grow: 1;
        }

        .delete-btn {
            background: transparent; /* Transparent background */
            border: none; /* No border */
            border-radius: 50%; /* Circular shape */
            padding: 4px; /* Small padding */
            color: var(--text-secondary); /* Muted text color */
            cursor: pointer;
            font-size: 0.8rem; /* Slightly larger font */
            transition: var(--transition);
            min-height: auto;
            min-width: auto;
            width: 22px; /* Smaller width */
            height: 22px; /* Smaller height */
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7; /* Semi-transparent */
        }

        .delete-btn:hover {
            background: rgba(231, 107, 107, 0.2); /* Reddish hover effect */
            opacity: 1; /* Full opacity on hover */
            transform: scale(1.15); /* Slightly enlarge on hover */
            color: #e76b6b;
        }

        .delete-icon {
            font-size: 0.8rem;
            line-height: 1;
        }

        .card-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .weather-main {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .weather-desc {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text);
            text-transform: capitalize;
        }

        .temp-main {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text);
        }

        .weather-details {
            display: flex;
            gap: 12px;
        }

        .detail-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 6px 8px;
            background: rgba(67, 97, 238, 0.08);
            border-radius: 4px;
            border: 1px solid rgba(67, 97, 238, 0.15);
        }

        .detail-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 2px;
        }

        .detail-value {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text);
        }

        .sort-btn {
            background: var(--data-card-bg);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            padding: 6px 10px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            min-height: 30px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .sort-btn:hover {
            background: var(--card-bg);
            border-color: var(--primary);
        }

        /* Responsive adjustments for larger screens */
        @media (min-width: 600px) {
            body {
                padding: 20px;
            }

            h1 {
                font-size: 2rem;
            }

            .subtitle {
                font-size: 1rem;
                margin-bottom: 25px;
            }

            .input-group {
                flex-direction: row;
            }

            input {
                min-width: 200px;
            }

            .card {
                padding: 25px;
                margin-bottom: 20px;
            }

            .data-card .value {
                font-size: 1.6rem;
            }

            .weather-cards-container {
                grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
                gap: 12px;
            }

            .weather-main {
                justify-content: space-between;
            }
        }

        @media (min-width: 768px) {
            .input-group {
                margin-bottom: 20px;
            }

            h1 {
                font-size: 2.2rem;
            }

            .data-card .value {
                font-size: 1.8rem;
            }

            .weather-data {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: 15px;
            }

            .data-card {
                padding: 20px;
            }

            .weather-details {
                gap: 10px;
            }

            .detail-item {
                padding: 6px 8px;
            }

            .weather-card {
                padding: 12px;
            }
        }

        @media (min-width: 1024px) {
            .weather-cards-container {
                grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Weather Dashboard</h1>
            <p class="subtitle">Check weather details for cities using wttr.in and view stored records</p>
            <div id="globalLastUpdated" class="last-updated" style="margin-top: 10px;"></div>
        </header>

        <main>
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div class="city-display">Enter a city to get weather details</div>
                    <button id="toggleInputBtn" class="sort-btn" style="min-height: auto; padding: 6px 12px;">▼</button>
                </div>

                <div id="inputSection" style="display: none;">
                    <div class="input-group">
                        <input type="text" id="cityInput" placeholder="Enter city name..." autocomplete="off">
                        <button id="submitBtn">Get Weather</button>
                    </div>

                    <div id="errorContainer"></div>
                    <div id="loading" class="loading" style="display: none;">Loading weather data...</div>
                    <div id="weatherContainer" style="display: none;">
                        <div class="last-updated" id="lastUpdated"></div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div style="font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 10px;">
                    <span>AQI (US):</span>
                    <span style="margin-left: 5px;">0-50(Good) | 51-100(Moderate) | 101-150(Unhealthy for Sensitive) | 151-200(Unhealthy) | 201-300(Very Unhealthy) | 301+(Hazardous)</span>
                </div>
                <h2>Weather Records</h2>
                <div id="sortControlsContainer" style="display: flex; justify-content: flex-end; align-items: center; margin-bottom: 15px;">
                    <!-- Sort buttons will be inserted here by JavaScript -->
                </div>
                <div class="weather-cards-container" id="weatherCardsContainer">
                    <!-- Weather cards will appear here -->
                </div>
            </div>
        </main>
    </div>

    <script>
        // DOM elements
        const cityInput = document.getElementById('cityInput');
        const submitBtn = document.getElementById('submitBtn');
        const toggleInputBtn = document.getElementById('toggleInputBtn');
        const inputSection = document.getElementById('inputSection');
        // Removed element references as their HTML elements were removed (no longer showing duplicate data)
        const weatherContainer = document.getElementById('weatherContainer');
        const loadingEl = document.getElementById('loading');
        const errorContainer = document.getElementById('errorContainer');
        const lastUpdatedEl = document.getElementById('lastUpdated');
        const weatherCardsContainer = document.getElementById('weatherCardsContainer');
        const globalLastUpdatedEl = document.getElementById('globalLastUpdated');

        // Helper function to format the date and time as hh:mm with "today" or date
        function formatDateTime(date) {
            const now = new Date();
            const isToday = date.toDateString() === now.toDateString();

            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const formattedTime = `${hours}:${minutes}`;

            if (isToday) {
                return `Last updated: ${formattedTime} (today)`;
            } else {
                const dateStr = date.toLocaleDateString();
                return `Last updated: ${formattedTime} (${dateStr})`;
            }
        }

        // Function to update global last updated time
        function updateGlobalLastUpdated() {
            const now = new Date();
            globalLastUpdatedEl.textContent = formatDateTime(now);

            // Store the last update time in localStorage
            localStorage.setItem('lastGlobalUpdateTime', now.toISOString());
        }

        // Function to load and display the global last updated time
        function loadGlobalLastUpdated() {
            const lastUpdateStr = localStorage.getItem('lastGlobalUpdateTime');
            if (lastUpdateStr) {
                const lastUpdate = new Date(lastUpdateStr);
                globalLastUpdatedEl.textContent = formatDateTime(lastUpdate);
            } else {
                globalLastUpdatedEl.textContent = 'Last updated: --:--';
            }
        }

        // Current sort state
        let currentSort = { field: 'name', order: 'asc' };

        // Load stored weather data from localStorage when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            loadStoredWeatherData();
            loadGlobalLastUpdated();

            // Refresh stored data on page load
            refreshStoredDataOnLoad();

            // Auto-refresh stored data every 5 minutes (300,000 milliseconds) - commented out due to API issues
            // setInterval(autoRefreshStoredData, 300000);
        });

        // Toggle input section visibility
        toggleInputBtn.addEventListener('click', () => {
            if (inputSection.style.display === 'none' || inputSection.style.display === '') {
                inputSection.style.display = 'block';
                toggleInputBtn.textContent = '▲';
                cityInput.focus(); // Focus the input field when expanded
            } else {
                inputSection.style.display = 'none';
                toggleInputBtn.textContent = '▼';
            }
        });

        // Submit button event listener
        submitBtn.addEventListener('click', handleFormSubmit);
        cityInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleFormSubmit();
            }
        });


        // Function to auto-refresh stored data using Open-Meteo API (only cache geocoding)
        async function autoRefreshStoredData() {
            const storedData = JSON.parse(localStorage.getItem('weatherData')) || [];

            if (storedData.length === 0) return; // Nothing to refresh

            // Update each stored city's data
            for (let i = 0; i < storedData.length; i++) {
                try {
                    const city = storedData[i].city;

                    // First, get coordinates for the city using OpenStreetMap's Nominatim API
                    // Check if we have cached coordinates for this city (cache geocoding results)
                    const geocodeCacheKey = `geocode_cache_${city.toLowerCase()}`;
                    let geocodeData = JSON.parse(localStorage.getItem(geocodeCacheKey)) || null;

                    if (!geocodeData) {
                        // Not cached, fetch coordinates
                        const geocodeResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=1&language=en&format=json`);

                        if (!geocodeResponse.ok) {
                            throw new Error(`Geocoding error! status: ${geocodeResponse.status}`);
                        }

                        geocodeData = await geocodeResponse.json();

                        if (!geocodeData.results || geocodeData.results.length === 0) {
                            throw new Error('City not found');
                        }

                        // Cache coordinates for 24 hours
                        const cacheEntry = {
                            timestamp: new Date().toISOString(),
                            data: geocodeData
                        };
                        localStorage.setItem(geocodeCacheKey, JSON.stringify(cacheEntry));
                    } else {
                        // Check if the cached data is still valid (less than 24 hours old)
                        const cacheTime = new Date(geocodeData.timestamp);
                        const now = new Date();
                        if (now - cacheTime > 24 * 60 * 60 * 1000) { // 24 hours
                            // Cache expired, fetch fresh coordinates
                            const geocodeResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=1&language=en&format=json`);

                            if (!geocodeResponse.ok) {
                                throw new Error(`Geocoding error! status: ${geocodeResponse.status}`);
                            }

                            geocodeData = await geocodeResponse.json();

                            if (!geocodeData.results || geocodeData.results.length === 0) {
                                throw new Error('City not found');
                            }

                            // Refresh the cache
                            const cacheEntry = {
                                timestamp: new Date().toISOString(),
                                data: geocodeData
                            };
                            localStorage.setItem(geocodeCacheKey, JSON.stringify(cacheEntry));
                        } else {
                            // Use the cached data
                            geocodeData = geocodeData.data;
                        }
                    }

                    const { latitude, longitude } = geocodeData.results[0];

                    // Now fetch weather and air quality data using the coordinates
                    const [weatherResponse, airQualityResponse] = await Promise.allSettled([
                        fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,relative_humidity_2m,apparent_temperature,weather_code&daily=temperature_2m_max,temperature_2m_min&timezone=auto`),
                        fetch(`https://air-quality-api.open-meteo.com/v1/air-quality?latitude=${latitude}&longitude=${longitude}&current=pm10,pm2_5,carbon_monoxide,nitrogen_dioxide,sulphur_dioxide,ozone,us_aqi&timezone=auto`)
                    ]);

                    if (weatherResponse.status === 'rejected' || !weatherResponse.value.ok) {
                        const errorStatus = weatherResponse.value ? weatherResponse.value.status : 'unknown';
                        throw new Error(`Weather API error! status: ${errorStatus}`);
                    }

                    if (airQualityResponse.status === 'rejected' || !airQualityResponse.value.ok) {
                        console.warn(`Air quality API error! status: ${airQualityResponse.value ? airQualityResponse.value.status : 'unknown'}. Proceeding with weather data only.`);
                    }

                    const weatherData = await weatherResponse.value.json();
                    let airQualityData = null;
                    try {
                        if (airQualityResponse.status === 'fulfilled' && airQualityResponse.value.ok) {
                            airQualityData = await airQualityResponse.value.json();
                        }
                    } catch (error) {
                        console.warn('Air quality data not available:', error);
                    }

                    if (weatherData && weatherData.current && weatherData.daily) {
                        // Extract weather data
                        const temperature = weatherData.current.temperature_2m;
                        const feelsLike = weatherData.current.apparent_temperature;
                        const humidity = weatherData.current.relative_humidity_2m;
                        const weatherCode = weatherData.current.weather_code;
                        const maxTemp = weatherData.daily.temperature_2m_max[0] || null;
                        const minTemp = weatherData.daily.temperature_2m_min[0] || null;

                        // Map weather code to description
                        const weatherDesc = getWeatherDescription(weatherCode);

                        // Extract air quality data if available
                        let airQuality = null;
                        if (airQualityData && airQualityData.current) {
                            airQuality = {
                                aqi: airQualityData.current.us_aqi || null,
                                pm2_5: airQualityData.current.pm2_5 || null,
                                pm10: airQualityData.current.pm10 || null,
                                o3: airQualityData.current.ozone || null,
                                no2: airQualityData.current.nitrogen_dioxide || null,
                                so2: airQualityData.current.sulphur_dioxide || null,
                                co: airQualityData.current.carbon_monoxide || null
                            };
                        }

                        // Update the stored data with new values (no caching of full weather data)
                        storedData[i].temperature = temperature;
                        storedData[i].feelsLike = feelsLike;
                        storedData[i].humidity = humidity;
                        storedData[i].weatherDesc = weatherDesc;
                        storedData[i].maxTemp = maxTemp;
                        storedData[i].minTemp = minTemp;
                        storedData[i].airQuality = airQuality;
                    }
                } catch (error) {
                    console.error(`API unavailable for ${storedData[i].city} (this is expected if API is blocking requests):`, error);
                    // Continue to next city instead of stopping the entire process
                    // Don't show error to user for background refresh, just log it
                }

                // Small delay between requests to avoid overwhelming the API
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            // Save updated data back to localStorage
            localStorage.setItem('weatherData', JSON.stringify(storedData));

            // Refresh the displayed cards
            loadStoredWeatherData();

            // Update global last updated time
            updateGlobalLastUpdated();
        }

        // Function to refresh stored data on page load using Open-Meteo API (only cache geocoding) - with error handling
        async function refreshStoredDataOnLoad() {
            const storedData = JSON.parse(localStorage.getItem('weatherData')) || [];

            if (storedData.length === 0) return; // Nothing to refresh

            // Update each stored city's data
            for (let i = 0; i < storedData.length; i++) {
                try {
                    const city = storedData[i].city;

                    // First, get coordinates for the city using OpenStreetMap's Nominatim API
                    // Check if we have cached coordinates for this city (cache geocoding results)
                    const geocodeCacheKey = `geocode_cache_${city.toLowerCase()}`;
                    let geocodeData = JSON.parse(localStorage.getItem(geocodeCacheKey)) || null;

                    if (!geocodeData) {
                        // Not cached, fetch coordinates
                        const geocodeResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=1&language=en&format=json`);

                        if (!geocodeResponse.ok) {
                            throw new Error(`Geocoding error! status: ${geocodeResponse.status}`);
                        }

                        geocodeData = await geocodeResponse.json();

                        if (!geocodeData.results || geocodeData.results.length === 0) {
                            throw new Error('City not found');
                        }

                        // Cache coordinates for 24 hours
                        const cacheEntry = {
                            timestamp: new Date().toISOString(),
                            data: geocodeData
                        };
                        localStorage.setItem(geocodeCacheKey, JSON.stringify(cacheEntry));
                    } else {
                        // Check if the cached data is still valid (less than 24 hours old)
                        const cacheTime = new Date(geocodeData.timestamp);
                        const now = new Date();
                        if (now - cacheTime > 24 * 60 * 60 * 1000) { // 24 hours
                            // Cache expired, fetch fresh coordinates
                            const geocodeResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=1&language=en&format=json`);

                            if (!geocodeResponse.ok) {
                                throw new Error(`Geocoding error! status: ${geocodeResponse.status}`);
                            }

                            geocodeData = await geocodeResponse.json();

                            if (!geocodeData.results || geocodeData.results.length === 0) {
                                throw new Error('City not found');
                            }

                            // Refresh the cache
                            const cacheEntry = {
                                timestamp: new Date().toISOString(),
                                data: geocodeData
                            };
                            localStorage.setItem(geocodeCacheKey, JSON.stringify(cacheEntry));
                        } else {
                            // Use the cached data
                            geocodeData = geocodeData.data;
                        }
                    }

                    const { latitude, longitude } = geocodeData.results[0];

                    // Now fetch weather and air quality data using the coordinates
                    const [weatherResponse, airQualityResponse] = await Promise.allSettled([
                        fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,relative_humidity_2m,apparent_temperature,weather_code&daily=temperature_2m_max,temperature_2m_min&timezone=auto`),
                        fetch(`https://air-quality-api.open-meteo.com/v1/air-quality?latitude=${latitude}&longitude=${longitude}&current=pm10,pm2_5,carbon_monoxide,nitrogen_dioxide,sulphur_dioxide,ozone,us_aqi&timezone=auto`)
                    ]);

                    if (weatherResponse.status === 'rejected' || !weatherResponse.value.ok) {
                        const errorStatus = weatherResponse.value ? weatherResponse.value.status : 'unknown';
                        throw new Error(`Weather API error! status: ${errorStatus}`);
                    }

                    if (airQualityResponse.status === 'rejected' || !airQualityResponse.value.ok) {
                        console.warn(`Air quality API error! status: ${airQualityResponse.value ? airQualityResponse.value.status : 'unknown'}. Proceeding with weather data only.`);
                    }

                    const weatherData = await weatherResponse.value.json();
                    let airQualityData = null;
                    try {
                        if (airQualityResponse.status === 'fulfilled' && airQualityResponse.value.ok) {
                            airQualityData = await airQualityResponse.value.json();
                        }
                    } catch (error) {
                        console.warn('Air quality data not available:', error);
                    }

                    if (weatherData && weatherData.current && weatherData.daily) {
                        // Extract weather data
                        const temperature = weatherData.current.temperature_2m;
                        const feelsLike = weatherData.current.apparent_temperature;
                        const humidity = weatherData.current.relative_humidity_2m;
                        const weatherCode = weatherData.current.weather_code;
                        const maxTemp = weatherData.daily.temperature_2m_max[0] || null;
                        const minTemp = weatherData.daily.temperature_2m_min[0] || null;

                        // Map weather code to description
                        const weatherDesc = getWeatherDescription(weatherCode);

                        // Extract air quality data if available
                        let airQuality = null;
                        if (airQualityData && airQualityData.current) {
                            airQuality = {
                                aqi: airQualityData.current.us_aqi || null,
                                pm2_5: airQualityData.current.pm2_5 || null,
                                pm10: airQualityData.current.pm10 || null,
                                o3: airQualityData.current.ozone || null,
                                no2: airQualityData.current.nitrogen_dioxide || null,
                                so2: airQualityData.current.sulphur_dioxide || null,
                                co: airQualityData.current.carbon_monoxide || null
                            };
                        }

                        // Update the stored data with new values (no caching of full weather data)
                        storedData[i].temperature = temperature;
                        storedData[i].feelsLike = feelsLike;
                        storedData[i].humidity = humidity;
                        storedData[i].weatherDesc = weatherDesc;
                        storedData[i].maxTemp = maxTemp;
                        storedData[i].minTemp = minTemp;
                        storedData[i].airQuality = airQuality;
                    }
                } catch (error) {
                    console.error(`API unavailable for ${storedData[i].city} (this is expected if API is blocking requests):`, error);
                    // Continue to next city instead of stopping the entire process
                    // Don't show error to user for background refresh, just log it
                }

                // Small delay between requests to avoid overwhelming the API
                await new Promise(resolve => setTimeout(resolve, 1000));
            }

            // Save updated data back to localStorage
            localStorage.setItem('weatherData', JSON.stringify(storedData));

            // Refresh the displayed cards
            loadStoredWeatherData();

            // Update global last updated time
            updateGlobalLastUpdated();
        }

        // Handle form submission
        function handleFormSubmit() {
            const city = cityInput.value.trim();
            if (!city) {
                showError('Please enter a city name');
                return;
            }

            // Fetch data
            fetchData(city);
        }

        // Fetch data from Open-Meteo API
        async function fetchData(city) {
            showLoading();
            hideError();

            try {
                // First, get coordinates for the city using OpenStreetMap's Nominatim API
                // Check if we have cached coordinates for this city (cache geocoding results)
                const geocodeCacheKey = `geocode_cache_${city.toLowerCase()}`;
                let geocodeData = JSON.parse(localStorage.getItem(geocodeCacheKey)) || null;

                if (!geocodeData) {
                    // Not cached, fetch coordinates
                    const geocodeResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=1&language=en&format=json`);

                    if (!geocodeResponse.ok) {
                        throw new Error(`Geocoding error! status: ${geocodeResponse.status}`);
                    }

                    geocodeData = await geocodeResponse.json();

                    if (!geocodeData.results || geocodeData.results.length === 0) {
                        throw new Error('City not found');
                    }

                    // Cache coordinates for 24 hours
                    const cacheEntry = {
                        timestamp: new Date().toISOString(),
                        data: geocodeData
                    };
                    localStorage.setItem(geocodeCacheKey, JSON.stringify(cacheEntry));
                } else {
                    // Check if the cached data is still valid (less than 24 hours old)
                    const cacheTime = new Date(geocodeData.timestamp);
                    const now = new Date();
                    if (now - cacheTime > 24 * 60 * 60 * 1000) { // 24 hours
                        // Cache expired, fetch fresh coordinates
                        const geocodeResponse = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(city)}&count=1&language=en&format=json`);

                        if (!geocodeResponse.ok) {
                            throw new Error(`Geocoding error! status: ${geocodeResponse.status}`);
                        }

                        geocodeData = await geocodeResponse.json();

                        if (!geocodeData.results || geocodeData.results.length === 0) {
                            throw new Error('City not found');
                        }

                        // Refresh the cache
                        const cacheEntry = {
                            timestamp: new Date().toISOString(),
                            data: geocodeData
                        };
                        localStorage.setItem(geocodeCacheKey, JSON.stringify(cacheEntry));
                    } else {
                        // Use the cached data
                        geocodeData = geocodeData.data;
                    }
                }

                const { latitude, longitude } = geocodeData.results[0];

                // Now fetch weather and air quality data using the coordinates
                const [weatherResponse, airQualityResponse] = await Promise.all([
                    fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,relative_humidity_2m,apparent_temperature,weather_code&daily=temperature_2m_max,temperature_2m_min&timezone=auto`),
                    fetch(`https://air-quality-api.open-meteo.com/v1/air-quality?latitude=${latitude}&longitude=${longitude}&current=pm10,pm2_5,carbon_monoxide,nitrogen_dioxide,sulphur_dioxide,ozone,us_aqi&timezone=auto`)
                ]);

                if (!weatherResponse.ok) {
                    throw new Error(`Weather API error! status: ${weatherResponse.status}`);
                }

                if (!airQualityResponse.ok) {
                    console.warn(`Air quality API error! status: ${airQualityResponse.status}. Proceeding with weather data only.`);
                }

                const weatherData = await weatherResponse.json();
                let airQualityData = null;
                try {
                    airQualityData = await airQualityResponse.json();
                } catch (error) {
                    console.warn('Air quality data not available:', error);
                }

                if (weatherData && weatherData.current && weatherData.daily) {
                    // Extract weather data
                    const temperature = weatherData.current.temperature_2m;
                    const feelsLike = weatherData.current.apparent_temperature;
                    const humidity = weatherData.current.relative_humidity_2m;
                    const weatherCode = weatherData.current.weather_code;
                    const maxTemp = weatherData.daily.temperature_2m_max[0] || null;
                    const minTemp = weatherData.daily.temperature_2m_min[0] || null;

                    // Map weather code to description (simplified mapping)
                    const weatherDesc = getWeatherDescription(weatherCode);

                    // Extract air quality data if available
                    let airQuality = null;
                    if (airQualityData && airQualityData.current) {
                        airQuality = {
                            aqi: airQualityData.current.us_aqi || null,
                            pm2_5: airQualityData.current.pm2_5 || null,
                            pm10: airQualityData.current.pm10 || null,
                            o3: airQualityData.current.ozone || null,
                            no2: airQualityData.current.nitrogen_dioxide || null,
                            so2: airQualityData.current.sulphur_dioxide || null,
                            co: airQualityData.current.carbon_monoxide || null
                        };
                    }

                    // The individual display elements were removed as duplicate data
                    // The data is now only shown in the weather cards below

                    // Show data container and update timestamp
                    weatherContainer.style.display = 'block';
                    lastUpdatedEl.textContent = `Last updated: ${new Date().toLocaleString()}`;

                    // Store this data in localStorage
                    storeWeatherData(city, temperature, feelsLike, humidity, weatherDesc, maxTemp, minTemp, airQuality);

                    // Update the displayed cards
                    loadStoredWeatherData();

                    // Update global last updated time
                    updateGlobalLastUpdated();
                } else {
                    showError('City not found or data unavailable');
                }
            } catch (error) {
                console.error('Error fetching weather data:', error);
                if (error.message.includes('CORS')) {
                    showError('CORS error: Unable to fetch weather data. The API might not allow browser requests.');
                } else if (error.message.includes('HTTP error')) {
                    showError(`HTTP error: ${error.message}. Please check if the city name is correct.`);
                } else if (error.message.includes('Failed to fetch') || error.message.includes('connection')) {
                    showError('Connection error: Unable to reach weather service. The API might be temporarily unavailable.');
                } else {
                    showError(error.message || 'Error fetching weather data. Please try again or check browser console for more details.');
                }
            } finally {
                hideLoading();
            }
        }

        // Function to get weather description from weather code
        function getWeatherDescription(code) {
            const weatherCodes = {
                0: 'Clear sky',
                1: 'Mainly clear',
                2: 'Partly cloudy',
                3: 'Overcast',
                45: 'Fog',
                48: 'Depositing rime fog',
                51: 'Light drizzle',
                53: 'Moderate drizzle',
                55: 'Dense drizzle',
                56: 'Light freezing drizzle',
                57: 'Dense freezing drizzle',
                61: 'Slight rain',
                63: 'Moderate rain',
                65: 'Heavy rain',
                66: 'Light freezing rain',
                67: 'Heavy freezing rain',
                71: 'Slight snow fall',
                73: 'Moderate snow fall',
                75: 'Heavy snow fall',
                77: 'Snow grains',
                80: 'Slight rain showers',
                81: 'Moderate rain showers',
                82: 'Violent rain showers',
                85: 'Slight snow showers',
                86: 'Heavy snow showers',
                95: 'Thunderstorm',
                96: 'Thunderstorm with slight hail',
                99: 'Thunderstorm with heavy hail'
            };
            return weatherCodes[code] || 'Weather condition';
        }

        // Store weather data in localStorage
        function storeWeatherData(city, temperature, feelsLike, humidity, weatherDesc, maxTemp, minTemp, airQuality = null) {
            let storedData = JSON.parse(localStorage.getItem('weatherData')) || [];

            // Check if city already exists, update if it does
            const existingIndex = storedData.findIndex(item => item.city.toLowerCase() === city.toLowerCase());

            // Convert '--' string back to null for storage
            const finalMaxTemp = maxTemp === '--' || maxTemp === null ? null : maxTemp;
            const finalMinTemp = minTemp === '--' || minTemp === null ? null : minTemp; // Fixed typo here

            if (existingIndex !== -1) {
                // Update existing record
                storedData[existingIndex].temperature = temperature;
                storedData[existingIndex].feelsLike = feelsLike;
                storedData[existingIndex].humidity = humidity;
                storedData[existingIndex].weatherDesc = weatherDesc;
                storedData[existingIndex].maxTemp = finalMaxTemp;
                storedData[existingIndex].minTemp = finalMinTemp;
                storedData[existingIndex].airQuality = airQuality;
            } else {
                // Add new record
                storedData.push({
                    city,
                    temperature,
                    feelsLike,
                    humidity,
                    weatherDesc,
                    maxTemp: finalMaxTemp,
                    minTemp: finalMinTemp,
                    airQuality: airQuality
                });
            }

            // Store back to localStorage
            localStorage.setItem('weatherData', JSON.stringify(storedData));
        }

        // Function to sort weather data
        function sortWeatherData(data, field, order) {
            return data.sort((a, b) => {
                let valueA, valueB;

                switch (field) {
                    case 'name':
                        valueA = a.city.toLowerCase();
                        valueB = b.city.toLowerCase();
                        break;
                    case 'maxTemp':
                        valueA = a.maxTemp === null ? -Infinity : parseFloat(a.maxTemp);
                        valueB = b.maxTemp === null ? -Infinity : parseFloat(b.maxTemp);
                        break;
                    case 'minTemp':
                        valueA = a.minTemp === null ? -Infinity : parseFloat(a.minTemp);
                        valueB = b.minTemp === null ? -Infinity : parseFloat(b.minTemp);
                        break;
                    default:
                        valueA = a.city.toLowerCase();
                        valueB = b.city.toLowerCase();
                }

                // Handle comparison based on order
                if (order === 'asc') {
                    return valueA < valueB ? -1 : valueA > valueB ? 1 : 0;
                } else {
                    return valueA > valueB ? -1 : valueA < valueB ? 1 : 0;
                }
            });
        }

        // Function to get sort indicator (arrow)
        function getSortIndicator(field) {
            if (currentSort.field === field) {
                return currentSort.order === 'asc' ? ' ↑' : ' ↓';
            }
            return '';
        }

        // Function to render sort controls
        function renderSortControls() {
            const container = document.getElementById('sortControlsContainer');
            container.innerHTML = `
                <div class="sort-controls" style="display: flex; gap: 8px;">
                    <button class="sort-btn" onclick="setSort('name')" title="Sort by city name" style="
                        background: var(--data-card-bg);
                        color: var(--text);
                        border: 1px solid var(--border);
                        border-radius: var(--border-radius);
                        padding: 6px 10px;
                        font-size: 0.85rem;
                        font-weight: 600;
                        cursor: pointer;
                        transition: var(--transition);
                        min-height: 30px;
                        display: flex;
                        align-items: center;
                        gap: 4px;
                    ">
                        Name<span>${getSortIndicator('name')}</span>
                    </button>
                    <button class="sort-btn" onclick="setSort('minTemp')" title="Sort by minimum temperature" style="
                        background: var(--data-card-bg);
                        color: var(--text);
                        border: 1px solid var(--border);
                        border-radius: var(--border-radius);
                        padding: 6px 10px;
                        font-size: 0.85rem;
                        font-weight: 600;
                        cursor: pointer;
                        transition: var(--transition);
                        min-height: 30px;
                        display: flex;
                        align-items: center;
                        gap: 4px;
                    ">
                        Min Temp<span>${getSortIndicator('minTemp')}</span>
                    </button>
                    <button class="sort-btn" onclick="setSort('maxTemp')" title="Sort by maximum temperature" style="
                        background: var(--data-card-bg);
                        color: var(--text);
                        border: 1px solid var(--border);
                        border-radius: var(--border-radius);
                        padding: 6px 10px;
                        font-size: 0.85rem;
                        font-weight: 600;
                        cursor: pointer;
                        transition: var(--transition);
                        min-height: 30px;
                        display: flex;
                        align-items: center;
                        gap: 4px;
                    ">
                        Max Temp<span>${getSortIndicator('maxTemp')}</span>
                    </button>
                </div>
            `;
        }

        // Function to set sort and reload data
        function setSort(field) {
            // If clicking the same field, toggle order; otherwise set to ascending
            if (currentSort.field === field) {
                currentSort.order = currentSort.order === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.field = field;
                currentSort.order = 'asc';
            }
            loadStoredWeatherData(); // Reload with new sort
        }

        // Load stored weather data from localStorage and populate the cards
        function loadStoredWeatherData() {
            let storedData = JSON.parse(localStorage.getItem('weatherData')) || [];

            // Sort the data
            storedData = sortWeatherData(storedData, currentSort.field, currentSort.order);

            // Render sort controls
            renderSortControls();

            weatherCardsContainer.innerHTML = '';

            storedData.forEach((item, index) => {
                // Create card element
                const card = document.createElement('div');
                card.className = 'weather-card';

                card.innerHTML = `
                    <div class="card-header">
                        <h3 class="city-name">${item.city}</h3>
                        <button class="delete-btn" onclick="deleteWeatherRecord(${index})" title="Delete record">
                            <span class="delete-icon">🗑️</span>
                        </button>
                    </div>
                    <div class="card-content">
                        <div class="weather-main">
                            <div class="temp-main">${item.feelsLike}°C</div>
                            <div class="weather-desc">${item.weatherDesc}</div>
                        </div>
                        <div class="weather-details">
                            <div class="detail-item">
                                <span class="detail-label">Max</span>
                                <span class="detail-value">${item.maxTemp !== null ? item.maxTemp + '°C' : '--°C'}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Min</span>
                                <span class="detail-value">${item.minTemp !== null ? item.minTemp + '°C' : '--°C'}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">Hum</span>
                                <span class="detail-value">${item.humidity}%</span>
                            </div>
                        </div>
                    </div>
                    ${item.airQuality ? `
                    <div class="air-quality-section" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border);">
                        <div class="weather-details">
                            <div class="detail-item">
                                <span class="detail-label">AQI</span>
                                <span class="detail-value">${item.airQuality.aqi !== null ? item.airQuality.aqi : '--'}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">PM2.5</span>
                                <span class="detail-value">${item.airQuality.pm2_5 !== null ? item.airQuality.pm2_5 + ' μg/m³' : '--'}</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">PM10</span>
                                <span class="detail-value">${item.airQuality.pm10 !== null ? item.airQuality.pm10 + ' μg/m³' : '--'}</span>
                            </div>
                        </div>
                    </div>
                    ` : ''}
                `;

                weatherCardsContainer.appendChild(card);
            });
        }

        // Delete a weather record
        function deleteWeatherRecord(index) {
            let storedData = JSON.parse(localStorage.getItem('weatherData')) || [];

            // Remove the item at the specified index
            storedData.splice(index, 1);

            // Update localStorage
            localStorage.setItem('weatherData', JSON.stringify(storedData));

            // Refresh the cards
            loadStoredWeatherData();

            // Update global last updated time
            updateGlobalLastUpdated();
        }


        // Show loading state
        function showLoading() {
            loadingEl.style.display = 'block';
            weatherContainer.style.display = 'none';
        }

        // Hide loading state
        function hideLoading() {
            loadingEl.style.display = 'none';
        }

        // Show error message
        function showError(message) {
            errorContainer.innerHTML = `<div class="error">${message}</div>`;
        }

        // Hide error message
        function hideError() {
            errorContainer.innerHTML = '';
        }

        // Make deleteWeatherRecord and setSort globally available for onclick
        window.deleteWeatherRecord = deleteWeatherRecord;
        window.setSort = setSort;
    </script>
</body>
</html>